This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-18T20:03:01.348Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
copy-images.mjs
copy-pdf.mjs

================================================================
Repository Files
================================================================

================
File: copy-images.mjs
================
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function ensureDir(dir) {
  try {
    await fs.access(dir);
  } catch {
    await fs.mkdir(dir, { recursive: true });
  }
}

async function removeDir(dir) {
  try {
    await fs.rm(dir, { recursive: true, force: true });
  } catch (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
  }
}

async function copyImages() {
  const contentDir = path.join(__dirname, '../src/content');
  const publicDir = path.join(__dirname, '../public/content');

  try {
    // Clear existing content directory in public
    await removeDir(publicDir);
    await ensureDir(publicDir);

    // Read all content directories
    const contentTypes = await fs.readdir(contentDir);

    for (const type of contentTypes) {
      const typeDir = path.join(contentDir, type);
      const stats = await fs.stat(typeDir);
      
      if (!stats.isDirectory()) continue;

      // Read all project directories
      const entries = await fs.readdir(typeDir);

      for (const entry of entries) {
        const entryDir = path.join(typeDir, entry);
        const stats = await fs.stat(entryDir);
        
        if (!stats.isDirectory()) continue;

        // Create target directory
        const publicEntryDir = path.join(publicDir, type, entry);
        await ensureDir(publicEntryDir);

        // Copy images
        const files = await fs.readdir(entryDir);
        for (const file of files) {
          if (/\.(jpg|jpeg|png|gif|webp|avif)$/i.test(file)) {
            await fs.copyFile(
              path.join(entryDir, file),
              path.join(publicEntryDir, file)
            );
          }
        }
      }
    }

    console.log('✓ Images copied successfully');
  } catch (error) {
    console.error('Error copying images:', error);
    process.exit(1);
  }
}

copyImages();

================
File: copy-pdf.mjs
================
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function ensureDir(dir) {
  try {
    await fs.access(dir);
  } catch {
    await fs.mkdir(dir, { recursive: true });
  }
}

async function removeDir(dir) {
  try {
    await fs.rm(dir, { recursive: true, force: true });
  } catch (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
  }
}

async function copyPDFs() {
  const contentDir = path.join(__dirname, '../src/content');
  const publicDir = path.join(__dirname, '../public/content');

  try {
    // Clear existing content directory in public
    await removeDir(publicDir);
    await ensureDir(publicDir);

    // Read all content directories
    const contentTypes = await fs.readdir(contentDir);

    for (const type of contentTypes) {
      const typeDir = path.join(contentDir, type);
      const stats = await fs.stat(typeDir);
      
      if (!stats.isDirectory()) continue;

      // Read all project directories
      const entries = await fs.readdir(typeDir);

      for (const entry of entries) {
        const entryDir = path.join(typeDir, entry);
        const stats = await fs.stat(entryDir);
        
        if (!stats.isDirectory()) continue;

        // Create target directory
        const publicEntryDir = path.join(publicDir, type, entry);
        await ensureDir(publicEntryDir);

        // Copy PDFs
        const files = await fs.readdir(entryDir);
        for (const file of files) {
          if (/\.pdf$/i.test(file)) {
            await fs.copyFile(
              path.join(entryDir, file),
              path.join(publicEntryDir, file)
            );
          }
        }
      }
    }

    console.log('✓ PDFs copied successfully');
  } catch (error) {
    console.error('Error copying PDFs:', error);
    process.exit(1);
  }
}

copyPDFs();

---

title: "My flight from Flask to React, through Streamlit and Dash"
summary: "Webpages seemed as the most boring part of programming, until I got into React. In this post I am thinking about my coding journey from backend to frontend."
date: "June 13 2025"
draft: true
category: tech
tags:
- React
- Frontend
- Typescript
- CHEESE
- Flask
- Vite
- Streamlit
- Dash
- Python 
- Tailwind
thumbnail: grid.jpg
toc: true
---


When I wrote my first line of code as a kid, it was probably some script to selfhost a Minecraft server, program for LEGO robot written in C, linux bash script, or a Java code in Processing. Later, I remember relieying heavily on Python with Jupyter Notebooks for data analysis. Web or frontend? I wasn't interested in it at all: it felt so boring.

## My flight from Flask to React, through Streamlit and Dash

In my first fullstack job I did program in Flask and used Jinja templates and Bootstrap: it worked up to some point, but every time I needed to go deeper outside of what the templates provide, It was a pain in the ass. Then in other projects I used usually a combination of Streamlit, Dash and Flask. Most of the time, I used a minimal friction setup, crafting frontend mostly out of necessity, not because i'd like it. Last year I tried to skim through some React basics and soon fell in love. Now I can consider myself a profficient frontend vibe-coder. Before outsourcing frontend to someone more experienced, I want to enjoy it for a while: even for an amateur, it feels so satisfactory.

![](grid.jpg)

## Example: My frontend stack at Deep MedChem

Let's move straight to these days. You can see sort of a progression from streamlit prototypes (such as Electrostatics or Modeller) to Flask+Dash dashboard in Explorer, up to the UI i am probably most proud of currently: CHEESE Search. I have no strong opinion about what is better or worse: the right approach is to know what you the end-product should be. Is it an MVP you should be able to get working overnight: then streamlit is probably the best choice. Hassle-free CRUD app integrated with sql: Flask+SQLAlchemy will probably win. Production-grade app which is highly maintainable and scalable, even if you spend 2x time on writing the code and checking types: then go for React with Typescript.    


| Product            | Stack                                            | Website     |
| ------------------ | ------------------------------------------------ | ----------- |
| **CHEESE**         | React + TypeScript + Vite + Tailwind | [cheese-new.deepmedchem.com](https://cheese-new.deepmedchem.com) |
| **Explorer**       | Flask + Python + Dash + HTML/CSS         | [explorer.deepmedchem.com](https://explorer.deepmedchem.com/) |
| **Electrostatics** | Streamlit + Python                   | [electrostatics.deepmedchem.com](http://electrostatics.deepmedchem.com/) |
| **Modeller**       | Streamlit + Python                   | [modeller.deepmedchem.com](http://modeller.deepmedchem.com/) |
| **Deep MedChem**       | Webflow | [deepmedchem.com](https://deepmedchem.com/) 

## Simple vs Complicated: What I hate in modern webdev

What intimidated at me when doing my first react hello world is the sheer number of files there are. While most technologies and tools for developers are getting simpler year by year, it seemed to me as if webdev got just 10x more convoluted over what I remember from days when html, php and css was enough. 

To illustrate my point, take how it looks after you create a new, say, NextJS project (excluding gitignored files):

```
└── hello_world
    ├── app
    │   ├── favicon.ico
    │   ├── globals.css
    │   ├── layout.tsx
    │   └── page.tsx
    ├── eslint.config.mjs
    ├── next.config.ts
    ├── package-lock.json
    ├── package.json
    ├── postcss.config.mjs
    ├── public
    │   ├── file.svg
    │   ├── globe.svg
    │   ├── next.svg
    │   ├── vercel.svg
    │   └── window.svg
    ├── README.md
    └── tsconfig.json

4 directories, 16 files
```

And compare it with a similar streamlit project:
```
hello_world.py
```
